# .github/workflows/deploy.yml
name: Health Guide CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  # Backend URL - will be set after backend deployment
  BACKEND_URL: ${{ secrets.RAILWAY_URL || 'https://your-app-name.up.railway.app' }}
  FRONTEND_URL: ${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}

jobs:
  # Django Backend Pipeline (runs first)
  backend:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./backend
    
    strategy:
      matrix:
        python-version: [3.9, 3.10, 3.11]
    
    outputs:
      backend-url: ${{ steps.deploy.outputs.url }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install flake8 black pytest pytest-django coverage
    
    - name: Lint with flake8
      run: |
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
    
    - name: Format check with black
      run: black --check .
    
    - name: Configure Django settings for integration
      run: |
        # Create production settings with CORS configuration
        cat >> health_guide/settings/production.py << EOF
        from .base import *
        
        # CORS settings for frontend integration
        CORS_ALLOWED_ORIGINS = [
            "https://${{ env.FRONTEND_URL }}",
            "https://${{ github.repository_owner }}.github.io",
        ]
        
        if DEBUG:
            CORS_ALLOWED_ORIGINS.append("http://localhost:3000")
            CORS_ALLOWED_ORIGINS.append("http://127.0.0.1:8000")
        
        CORS_ALLOW_CREDENTIALS = True
        CORS_ALLOW_ALL_ORIGINS = False
        
        # API settings
        REST_FRAMEWORK = {
            'DEFAULT_RENDERER_CLASSES': [
                'rest_framework.renderers.JSONRenderer',
            ],
            'DEFAULT_PERMISSION_CLASSES': [
                'rest_framework.permissions.IsAuthenticatedOrReadOnly',
            ],
        }
        
        # Static files for API documentation
        STATIC_URL = '/static/'
        STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')
        EOF
    
    - name: Run Django checks
      run: |
        python manage.py check
      env:
        DJANGO_SETTINGS_MODULE: health_guide.settings.production
    
    - name: Run tests
      run: |
        coverage run --source='.' manage.py test
        coverage report
        coverage xml
      env:
        DJANGO_SETTINGS_MODULE: health_guide.settings.test
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./backend/coverage.xml
        flags: backend
    
    # Build Docker image with production settings
    - name: Build Docker image
      run: |
        cat > Dockerfile.prod << EOF
        FROM python:3.11-slim
        WORKDIR /app
        COPY requirements.txt .
        RUN pip install -r requirements.txt
        COPY . .
        ENV DJANGO_SETTINGS_MODULE=health_guide.settings.production
        CMD ["gunicorn", "--bind", "0.0.0.0:8000", "health_guide.wsgi:application"]
        EOF
        docker build -f Dockerfile.prod -t health-guide-backend .
    
    # Deploy to Railway
    - name: Deploy to Railway
      id: deploy
      if: github.ref == 'refs/heads/main'
      uses: railway-app/cli-action@v1
      with:
        railway-token: ${{ secrets.RAILWAY_TOKEN }}
        command: up --service backend
      env:
        RAILWAY_SERVICE: backend
    
    - name: Set backend URL output
      id: backend-url
      run: echo "url=${{ env.BACKEND_URL }}" >> $GITHUB_OUTPUT

  # Frontend Pipeline (depends on backend)
  frontend:
    runs-on: ubuntu-latest
    needs: backend
    defaults:
      run:
        working-directory: ./frontend
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    
    # Create configuration for backend integration
    - name: Configure frontend for backend integration
      run: |
        # Create API configuration file
        cat > js/config.js << EOF
        // API Configuration
        const API_CONFIG = {
            BASE_URL: '${{ env.BACKEND_URL }}',
            ENDPOINTS: {
                // Health endpoints
                health_check: '/api/health/',
                conditions: '/api/conditions/',
                symptoms: '/api/symptoms/',
                treatments: '/api/treatments/',
                
                // User endpoints
                auth: '/api/auth/',
                profile: '/api/profile/',
                
                // Search endpoints
                search: '/api/search/',
            },
            HEADERS: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest',
            }
        };
        
        // API Helper functions
        class HealthAPI {
            constructor() {
                this.baseURL = API_CONFIG.BASE_URL;
            }
            
            async request(endpoint, options = {}) {
                const url = \`\${this.baseURL}\${endpoint}\`;
                const config = {
                    headers: API_CONFIG.HEADERS,
                    ...options
                };
                
                try {
                    const response = await fetch(url, config);
                    if (!response.ok) {
                        throw new Error(\`HTTP error! status: \${response.status}\`);
                    }
                    return await response.json();
                } catch (error) {
                    console.error('API request failed:', error);
                    throw error;
                }
            }
            
            // Health data methods
            async getConditions() {
                return this.request(API_CONFIG.ENDPOINTS.conditions);
            }
            
            async getSymptoms() {
                return this.request(API_CONFIG.ENDPOINTS.symptoms);
            }
            
            async searchHealth(query) {
                return this.request(\`\${API_CONFIG.ENDPOINTS.search}?q=\${encodeURIComponent(query)}\`);
            }
        }
        
        // Global API instance
        window.healthAPI = new HealthAPI();
        EOF
        
        # Update index.html to include API configuration
        if [ -f "index.html" ]; then
          sed -i '/<head>/a\    <script src="js/config.js"></script>' index.html
        fi
        
        # Create a sample integration in main JavaScript file
        if [ -f "js/main.js" ]; then
          cat >> js/main.js << EOF
        
        // Backend Integration Example
        document.addEventListener('DOMContentLoaded', async function() {
            try {
                // Test backend connection
                const healthCheck = await window.healthAPI.request('/api/health/');
                console.log('Backend connected successfully:', healthCheck);
                
                // Load initial data from backend
                const conditions = await window.healthAPI.getConditions();
                console.log('Loaded conditions:', conditions);
                
            } catch (error) {
                console.warn('Backend connection failed:', error);
                // Fallback to static data or show offline message
            }
        });
        EOF
        fi
    
    # Install build dependencies if package.json exists
    - name: Install build dependencies
      run: |
        if [ -f "package.json" ]; then
          npm ci
        else
          # Create basic package.json for linting tools
          cat > package.json << EOF
        {
          "name": "health-guide-frontend",
          "version": "1.0.0",
          "scripts": {
            "build": "echo 'Build completed'",
            "lint": "eslint js/ --fix"
          },
          "devDependencies": {
            "eslint": "^8.0.0",
            "stylelint": "^15.0.0"
          }
        }
        EOF
          npm install
        fi
    
    # Validate HTML
    - name: Validate HTML
      run: |
        sudo apt-get update
        sudo apt-get install -y tidy
        find . -name "*.html" -exec tidy -q -e {} \; || true
    
    # Lint CSS
    - name: Lint CSS
      run: |
        if [ -f "package.json" ]; then
          npx stylelint "**/*.css" --fix || echo "CSS linting completed with warnings"
        fi
    
    # Lint JavaScript
    - name: Lint JavaScript
      run: |
        if [ -f "package.json" ]; then
          npx eslint "**/*.js" --fix || echo "JS linting completed with warnings"
        fi
    
    # Build optimized version
    - name: Build frontend
      run: |
        # Minify CSS and JS if build tools are available
        if [ -f "package.json" ]; then
          npm run build || echo "No build script found, using files as-is"
        fi
        
        # Ensure all API configurations are properly set
        echo "Frontend build completed with backend URL: ${{ env.BACKEND_URL }}"
    
    - name: Upload frontend artifacts
      uses: actions/upload-artifact@v4
      with:
        name: frontend-build
        path: ./frontend
    
    # Deploy to GitHub Pages
    - name: Deploy to GitHub Pages
      if: github.ref == 'refs/heads/main'
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./frontend
        publish_branch: gh-pages

  # Integration Testing
  integration-test:
    runs-on: ubuntu-latest
    needs: [frontend, backend]
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js for testing
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    
    - name: Install testing dependencies
      run: |
        npm install -g playwright
        playwright install chromium
    
    - name: Wait for deployments
      run: |
        echo "Waiting for deployments to be ready..."
        sleep 60
    
    - name: Test frontend-backend integration
      run: |
        cat > integration-test.js << EOF
        const { chromium } = require('playwright');
        
        (async () => {
          const browser = await chromium.launch();
          const page = await browser.newPage();
          
          // Test frontend loads
          console.log('Testing frontend deployment...');
          await page.goto('https://${{ env.FRONTEND_URL }}');
          
          // Test API connection
          console.log('Testing backend API connection...');
          const response = await page.evaluate(async () => {
            try {
              const response = await fetch('${{ env.BACKEND_URL }}/api/health/');
              return { status: response.status, ok: response.ok };
            } catch (error) {
              return { error: error.message };
            }
          });
          
          console.log('API Response:', response);
          
          if (response.ok) {
            console.log('✅ Integration test passed!');
          } else {
            console.log('❌ Integration test failed!');
            process.exit(1);
          }
          
          await browser.close();
        })();
        EOF
        
        node integration-test.js

  # Security Scanning
  security:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  # Deployment notification
  notify:
    runs-on: ubuntu-latest
    needs: [frontend, backend, integration-test]
    if: always()
    steps:
    - name: Notify deployment status
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        text: |
          Health Guide Deployment Status: ${{ job.status }}
          Frontend: https://${{ env.FRONTEND_URL }}
          Backend: ${{ env.BACKEND_URL }}
          Integration Tests: ${{ needs.integration-test.result }}
      if: always()